#!/bin/sh
# Copyright 1997-2004 Apple Computer, Inc.

stty intr undef kill undef quit undef susp undef start undef stop undef dsusp undef

. /etc/rc.common

SafeBoot=""
VerboseFlag=""
FsckSlash=""
NetBoot=""

args=$(/usr/bin/getopt xvFN $*)
set -- ${args};
for option; do
    case "${option}" in
      -v)
        VerboseFlag="-v"
	;;
      -x)
        SafeBoot="-x"
	;;
      -F)
        FsckSlash="-F"
	;;
      -N)
        NetBoot="-N"
	;;
    esac;
done;

function fsck_slash {

if [ "${NetBoot}" = "-N" ] ; then
    echo "Initializing NetBoot"
    if ! sh /etc/rc.netboot start ; then
	echo NetBoot initialization failed, shut down in 10 seconds...
	sleep 10
	echo Shutting down.
	halt
    fi
fi

fsckerror=0

# We're neither single-user nor on a CD-ROM.
# Erase the rom's old-style login panel
echo "Checking disk"

# Benignly clean up ("preen") any dirty filesystems. 
# fsck -p will skip disks which were properly unmounted during
# a normal shutdown.
# fsck always runs during SafeBoot
if [ "${SafeBoot}" = "-x" ]; then
	fsck -fy
else
	fsck -p
fi

# fsck's success is reflected in its status.
case $? in
0)
	# No problems
	;;
2) 
	# Request was made (via SIGQUIT, ^\) to complete fsck
	# but prevent going multi-user.
	echo "Request to remain single-user received"
	fsckerror=1
	;;
4)
	# The root filesystem was checked and fixed.  Let's reboot.
	# Note that we do NOT sync the disks before rebooting, to
	# ensure that the filesystem versions of everything fsck fixed
	# are preserved, rather than being overwritten when in-memory
	# buffers are flushed.
	echo "Root filesystem fixed - rebooting"
	reboot -q -n
	;;
8)
	# Serious problem was found.
	echo "Reboot failed - serious errors"
	fsckerror=1
	;;
12)
	# fsck was interrupted by SIGINT (^C)
	echo "Reboot interrupted"
	fsckerror=1
	;;
*)
	# Some other error condition ocurred.
	echo "Unknown error while checking disks"
	fsckerror=1
	;;
esac

##
# Try fsck -fy and reboot if the above fails horribly.
# This may create a neverending cycle if your root disk is unrecoverably
#  frobbed, and the only recourse them is to power down or boot single
#  user and hope you know what you're doing.
##
if [ ${fsckerror} -ne 0 ]; then
	fsck -fy
	reboot
fi

}

if [ -d /System/Installation -a -f /etc/rc.cdrom ]; then
	/etc/rc.cdrom multiuser
	# We shouldn't get here; CDIS should reboot the machine when done
	echo "CD-ROM boot procedure complete"
	halt
fi

if [ "${FsckSlash}" = "-F" ]; then
	fsck_slash
fi

# Mount essential local filesystems (according to /etc/fstab).
echo "Mounting local filesystems"

mount_fdesc -o union fdesc /dev
mkdir -p -m 0555 /.vol
mount_volfs /.vol
mount -vat nonfs

BootCacheControl=/System/Library/Extensions/BootCache.kext/Contents/Resources/BootCacheControl
if [ ! -f $BootCacheControl ]; then
	BootCacheControl=/usr/sbin/BootCacheControl
fi
if [ "${SafeBoot}" != "-x" -a -x "${BootCacheControl}" ]; then
	${BootCacheControl} start
fi

# System tuning
if [ -f /etc/sysctl-macosxserver.conf ]; then
	awk '{ if (!index($1, "#") && index($1, "=")) print $1 }' < /etc/sysctl-macosxserver.conf | while read
	do
		sysctl -w ${REPLY}
	done
fi
if [ -f /etc/sysctl.conf ]; then
	awk '{ if (!index($1, "#") && index($1, "=")) print $1 }' < /etc/sysctl.conf | while read
	do
		sysctl -w ${REPLY}
	done
fi
sysctl -w kern.sysv.shmmax=4194304 kern.sysv.shmmin=1 kern.sysv.shmmni=32 kern.sysv.shmseg=8 kern.sysv.shmall=1024

if [ -f /etc/rc.installer_cleanup ]; then
	/etc/rc.installer_cleanup multiuser
fi

echo "Resetting files and devices"

RMRF_ITEMS=""
##
# Attempt to recover the passwd file, if needed.  This procedure is
# primarily historical and makes sense only when the passwd file is edited
# using the vipw command.  
##
if [ -s /etc/ptmp ]; then
	if [ -s /etc/passwd ]; then
		echo -n "Passwd file conflict with ptmp: "
		ls -l /etc/passwd /etc/ptmp
		echo "Moving ptmp to ptmp.save"
		mv -f /etc/ptmp /etc/ptmp.save
	else
		echo "Passwd file recovered from ptmp"
		mv /etc/ptmp /etc/passwd
	fi
elif [ -r /etc/ptmp ]; then
	echo "Removing passwd lock file"
	RMRF_ITEMS="$RMRF_ITEMS /etc/ptmp"
fi

##
# If the shutdown command was used to shut the system down, the file
# /etc/nologin may have been created to prevent users from logging in.  
# Remove it so that logins are enabled when the system comes up.
##
RMRF_ITEMS="$RMRF_ITEMS /etc/nologin"

# Clean out /private/tmp.
if [ -d /private/tmp ]; then
	# blow away any _tmp_ in case it exists as well
	if [ -e /private/_tmp_ ]; then
		chflags -R nouchg /private/_tmp_
		rm -rf /private/_tmp_
	fi
	echo -n " /private/tmp"
	mv /private/tmp /private/_tmp_
	chflags -R nouchg /private/_tmp_
	RMRF_ITEMS="$RMRF_ITEMS /private/_tmp_"
fi
mkdir -p -m 01777 /private/var/tmp /private/tmp

# Clear /private/Network (created by automount).
if [ -d /private/Network ]; then
	# blow away any _Network_ in case it exists as well
	if [ -e /private/_Network_ ]; then
		chflags -R nouchg /private/_Network_
		rm -rf /private/_Network_
	fi

	echo -n " /private/Network"
	mv /private/Network /private/_Network_
	find -xd /private/_Network_ -type d -print0 | xargs -0 rmdir
fi

# Move /var/run out of the way
if [ -d /var/run ]; then
	# blow away any _run_ in case it exists as well
	if [ -e /var/_run_ ]; then
		chflags -R nouchg /var/_run_
		rm -rf /var/_run_
	fi
	mv /var/run /var/_run_
fi

# Make new /var/run
mkdir -m 775 /var/run
mkdir -m 775 /var/run/StartupItems /var/run/davlocks
mkdir -m 755 /var/run/proxy
chown root:daemon /var/run /var/run/StartupItems
chown www:www /var/run/proxy /var/run/davlocks

# Move sudo back to /var/run, touch the contents of /var/run/sudo/* back to the epoch
if [ -d /var/_run_/sudo ]; then
	mv /var/_run_/sudo /var/run/sudo
	touch -t 198501010000 /var/run/sudo/*
fi

# Clear utmp (who is logged on).
touch /var/run/utmp /var/run/utmpx

# purge the _run_ directory if it exists
if [ -d /var/_run_ ]; then
	chflags -R nouchg /var/_run_
	RMRF_ITEMS="$RMRF_ITEMS /var/_run_"
fi

# Clear /var/spool/lock
purgedir /var/spool/lock


# if "/Desktop Folder" exists and has contents, make sure there is a
#   "/Desktop (Mac OS 9)" symlink to it
# if "/Desktop Folder" does not exist, exists but has no contents, or exists
#   and has only a single file, ".DS_Store" then there should be no
#   "/Desktop (Mac OS 9)" symlink
# if there is some other file or directory with the name "/Desktop (Mac OS 9)"
#   then just exit
needlink=0
if [ -d "/Desktop Folder" ]; then
	needlink=$(ls -a1 "/Desktop Folder" | wc -l)
	if [ "${needlink}" -eq 3 ]; then
		if [ -f "/Desktop Folder/.DS_Store" ]; then
			needlink=0
		fi
	fi
fi

if [ "${needlink}" -lt 3 ]; then
	if [ -h "/Desktop (Mac OS 9)" ]; then
		rm -f "/Desktop (Mac OS 9)"
	fi
else
	if ! [ -e "/Desktop (Mac OS 9)" ]; then
		ln -s "/Desktop Folder" "/Desktop (Mac OS 9)"
	fi
fi

echo Removing $RMRF_ITEMS
rm -rf $RMRF_ITEMS

# Logs are important. Start syslogd after the boot disk becomes r/w but before
# everything else starts. In the future, we should launch this lazily when it
# is first needed.
/usr/sbin/syslogd -s -m 0

# Create mach symbol file
rm -f /mach.sym
sysctl -n kern.symfile
if [ -f /mach.sym ]; then
  rm -f /mach
  ln -s /mach.sym /mach
else
  rm -f /mach
  ln -s /mach_kernel /mach
fi

if [ "${SafeBoot}" = "-x" ]; then
    echo "Configuring kernel extensions for safe boot"
    touch /private/tmp/.SafeBoot
    kextd -x
else
    echo "Configuring kernel extensions"
    kextd
fi

if [  "${SafeBoot}" != "-x" -a -x "${BootCacheControl}" ]; then
    ${BootCacheControl} tag
fi

# Load [ideally on demand] Mach bootstrap based services
/usr/libexec/register_mach_bootstrap_servers /etc/mach_init.d

# We hope to launch portmap on demand in the next major release of Mac OS X,
# but until then, we need to inline in here for reasons not worth going into in
# this file. Static reasons to run portmap today include:
#
# - if there are NFS exports, or
# - if NFS locking is on (NFSLOCKS=-YES-), or
# - if there are NetInfo domains other than "local", or
# - if the local domain has any non-loopback values for "trusted_networks".
# - if xinetd has a portmap based service
#
# Explicitly setting NETINFOSERVER=-YES- forces portmap to run.
#
# If portmap is not started now, it will be started later if
# NFSLOCKS=-AUTOMATIC- and an NFS locking request is made.
##
if [ "${RPCSERVER:=-AUTOMATIC-}" = "-AUTOMATIC-" ]; then
	RPCSERVER=-YES-
	nfs_exports_ni=$(nicl -raw /var/db/netinfo/local.nidb -list /exports 2> /dev/null | wc -w)
	nfs_exports_etc=$(grep -v '^[[:space:]]*\(#\|$\)' /etc/exports 2> /dev/null | wc -l)
	nfs_exports=$(($nfs_exports_ni + $nfs_exports_etc))
	ni_not_local=$(/bin/ls -1d /var/db/netinfo/*.nidb | sed 's:/var/db/netinfo/local.nidb::' | wc -w)
	ni_local_export=$(nicl -raw /var/db/netinfo/local.nidb -read / trusted_networks 2>&1 | sed 's/trusted_networks://' | sed 's/127[^ ]*//g' | wc -w)
	total=$(($nfs_exports + $ni_not_local + $ni_local_export))
	[ "${total}" -eq 0 ] && RPCSERVER=-NO-
	[ "${NFSLOCKS:=-AUTOMATIC-}" = "-YES-" ] && RPCSERVER=-YES-
	[ "${NETINFOSERVER:=-NO-}" = "-YES-" ] && RPCSERVER=-YES-
	[ "${NISDOMAIN:=-NO-}" != "-NO-" ] && RPCSERVER=-YES-
	grep -ri rpc /etc/xinetd.d >/dev/null 2>&1 && RPCSERVER=-YES-
fi

if [ "${RPCSERVER}" = "-YES-" ]; then
	portmap
fi

# We would also like to start "netinfo" on demand too, but we can't for various
# reasons at the moment. Start it here for now:
#
# Create local NetInfo database if it doesn't exist
if [ ! -d /var/db/netinfo/local.nidb ]; then
	echo "Creating local NetInfo database"
	mkdir -p /var/db/netinfo
	/usr/libexec/create_nidb
	rm -f /var/db/.AppleSetupDone
fi

# nibindd is required if there are NetInfo domains other than "local", or
# if the local domain has any non-loopback values for "trusted_networks".
if [ "${NETINFOSERVER:=-AUTOMATIC-}" = "-AUTOMATIC-" ]; then
	NETINFOSERVER=-YES-
	ni_not_local=$(/bin/ls -1d /var/db/netinfo/*.nidb | sed 's:/var/db/netinfo/local.nidb::' | wc -w)
	ni_local_export=$(nicl -raw /var/db/netinfo/local.nidb -read / trusted_networks 2>&1 | sed 's/trusted_networks://' | sed 's/127[^ ]*//g' | wc -w)
	total=$(($ni_not_local + $ni_local_export))
	if [ "${total}" -eq 0 ]; then
		NETINFOSERVER=-NO-
	fi
fi

# If nibindd is not required, we just start the local NetInfo daemon.
if [ "${NETINFOSERVER}" = "-YES-" ]; then
	nibindd
else
	cd /var/db/netinfo
	netinfod -s local
	cd /
fi

update

echo "Starting virtual memory"

swapdir=/private/var/vm
if [ "${NetBoot}" = "-N" ]; then
    sh /etc/rc.netboot setup_vm ${swapdir}
fi

# Make sure the swapfile exists
if [ ! -d ${swapdir} ]; then
    echo "Creating default swap directory"
    mount -uw /
    mkdir -p -m 755 ${swapdir}
    chown root:wheel ${swapdir}
else
    rm -rf ${swapdir}/swap*
fi
		    
if [ ${ENCRYPTSWAP:=-NO-} = "-YES-" ]; then
    encryptswap="-E"
else
    encryptswap=""
fi
dynamic_pager ${encryptswap} -F ${swapdir}/swapfile

appprofiledir=/private/var/vm/app_profile

if [ ! -d ${appprofiledir} ]; then
	if [ -f  ${appprofiledir} ]; then
		mv -f ${appprofiledir} "${appprofiledir}_" 
	fi
	mkdir -p -m 711 ${appprofiledir}
	chown root:wheel ${appprofiledir}
fi

SystemStarter ${VerboseFlag} ${SafeBoot}

# Set language from CDIS.custom - assumes this is parse-able by sh
if [ -f /var/log/CDIS.custom ]; then
	. /var/log/CDIS.custom 
fi

# Start the Language Chooser. This code should be able to go away as far as I
# know once loginwindow becomes dynamic and SystemStarter exits the GUI
# business.
STARTPBS="/System/Library/CoreServices/pbs"            # apps stall w/o
BUDDYCOOKIE="/var/db/.AppleSetupDone"
LCACOOKIE="/var/db/.RunLanguageChooserToo"
STARTLCA="/System/Library/CoreServices/Language Chooser.app/Contents/MacOS/Language Chooser"

if [ -x "$STARTLCA" -a -x "$STARTPBS" -a ! -f "$BUDDYCOOKIE" -a -f "$LCACOOKIE" ]; then
	"$STARTPBS" &
	pbspid=$!
	"$STARTLCA"
	kill $pbspid    # XSelect does this independently
fi

if [ ! -s "/var/log/CDIS.custom" ]; then
	echo "Language Chooser seems to have failed; defaulting to English"
	echo "LANGUAGE=English" > "/var/log/CDIS.custom"
fi

export LANGUAGE

touch /var/run/.systemStarterRunning

exit 0
