/*
 * Copyright (c) 1999-2004 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * "Portions Copyright (c) 1999 Apple Computer, Inc.  All Rights
 * Reserved.  This file contains Original Code and/or Modifications of
 * Original Code as defined in and that are subject to the Apple Public
 * Source License Version 1.0 (the 'License').  You may not use this file
 * except in compliance with the License.  Please obtain a copy of the
 * License at http://www.apple.com/publicsource and read it before using
 * this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License."
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * bootstrap -- fundamental service initiator and port server
 * Mike DeMoney, NeXT, Inc.
 * Copyright, 1990.  All rights reserved.
 *
 * bootstrap.c -- implementation of bootstrap main service loop
 */

#include <mach/mach.h>
#include <mach/mach_error.h>
#include <mach/boolean.h>
#include <mach/message.h>
#include <mach/notify.h>
#include <mach/mig_errors.h>
#include <mach/mach_traps.h>
#include <mach/mach_interface.h>
#include <mach/bootstrap.h>
#include <mach/host_info.h>
#include <mach/mach_host.h>
#include <mach/exception.h>
#include <servers/bootstrap_defs.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <sys/wait.h>
#include <sys/event.h>
#include <sys/queue.h>
#include <pthread.h>
#include <errno.h>
#include <string.h>
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <libc.h>
#include <paths.h>
#include <syslog.h>
#include <pwd.h>

/* <rdar://problem/2685209> sys/queue.h is not up to date */
#ifndef SLIST_FOREACH_SAFE
#define	SLIST_FOREACH_SAFE(var, head, field, tvar)			\
	for ((var) = SLIST_FIRST((head));				\
		(var) && ((tvar) = SLIST_NEXT((var), field), 1);	\
		(var) = (tvar))
#endif


#include "bootstrap.h"
#include "bootstrapServer.h"
#include "notifyServer.h"
#include "launchd.h"

struct bootstrap {
	kq_callback		kqbstrap_callback;
	SLIST_ENTRY(bootstrap)	sle;
	SLIST_HEAD(, bootstrap)	sub_bstraps;
	SLIST_HEAD(, server)	servers;
	SLIST_HEAD(, service)	services;
	struct bootstrap	*parent;
	mach_port_name_t	bootstrap_port;
	mach_port_name_t	requestor_port;
};

struct service {
	SLIST_ENTRY(service)	sle;
	struct bootstrap	*bootstrap;	/* bootstrap port(s) used at this level. */
	struct server		*server;	/* server, declared services only */
	mach_port_name_t	port;		/* service port, may have all rights if inactive */
	unsigned int		isActive:1, __junk:31;
	char			name[0];	/* service name */
};

struct server {
	kq_callback	kqserver_callback;
	SLIST_ENTRY(server)	sle;
	SLIST_HEAD(, service)	services;
	struct bootstrap *bootstrap; /* bootstrap context */
	mach_port_t	port;		/* server's priv bootstrap port */
	uid_t		uid;		/* uid to exec server with */
	pid_t		pid;		/* server's pid */
	int		active_services;	/* count of active services */
	unsigned int	ondemand:1, activity:1, __junk:30;
	char		cmd[0];		/* server command to exec */
};

static struct server *server_new(struct bootstrap *bootstrap, const char *cmd, uid_t uid, bool ond);
static void server_delete(struct server *serverp);
static void server_setup(struct server *serverp);
static bool server_active(struct server *serverp);
static bool server_useless(struct server *serverp);
static void server_start(struct server *serverp);
static void server_start_child(struct server *serverp);
static void server_reap(struct server *serverp);
static void server_reap_port(struct server *serverp);
static void server_dispatch(struct server *serverp);
static void server_callback(void *obj, struct kevent *kev);

static struct service *service_new(struct bootstrap *bootstrap, const char *name, mach_port_t *serviceport, struct server *serverp);
static void service_delete(struct service *servicep);
static void service_watch(struct service *servicep);

static struct bootstrap *bootstrap_new(struct bootstrap *parent, mach_port_name_t requestorport);
static void bootstrap_delete(struct bootstrap *bootstrap);
static void bootstrap_delete_anything_with_port(struct bootstrap *bootstrap, mach_port_t port);
static struct service *bootstrap_lookup_service(struct bootstrap *bootstrap, const char *name);
static void bootstrap_callback(void *obj, struct kevent *kev);

/* mach_init interposes bootstrap_server() generated by the mig tool with this function */
static boolean_t server_demux(mach_msg_header_t *Request, mach_msg_header_t *Reply);
static bool canReceive(mach_port_t);
static pid_t fork_with_bootstrap_port(mach_port_t p, bool dealloc);
static void init_ports(void);
static char **argvize(const char *string);
static void *demand_loop(void *arg);
static void mport_callback(void *obj, struct kevent *kev);

static struct bootstrap *root_bootstrap = NULL;
static struct bootstrap *ws_bootstrap = NULL;
static struct bootstrap *current_rpc_bootstrap = NULL;
static struct server *current_rpc_server = NULL;
static mach_port_t inherited_bootstrap_port = MACH_PORT_NULL;
static mach_port_t demand_port_set = MACH_PORT_NULL;
static mach_port_t notify_port = MACH_PORT_NULL;
static mach_port_t backup_port = MACH_PORT_NULL;
static bool force_on_demand = false;
static char *register_name = NULL;
static size_t port_to_obj_size = 0;
static void **port_to_obj = NULL;
static int active_ports_fd = -1;
static int port_to_main_thread_fd = -1;
static pthread_t demand_thread;
static kq_callback kqmport_callback = mport_callback;
static kq_callback kqbstrap_callback = bootstrap_callback;

static kern_return_t launchd_set_bport(mach_port_t name);
static kern_return_t launchd_get_bport(mach_port_t *name);
static kern_return_t launchd_mport_watch(mach_port_t name);
static kern_return_t launchd_mport_ignore(mach_port_t name);
static kern_return_t launchd_mport_create_recv(mach_port_t *name, void *obj);
static kern_return_t launchd_mport_deallocate(mach_port_t name);
static kern_return_t launchd_mport_make_send(mach_port_t name);
static kern_return_t launchd_mport_close_recv(mach_port_t name);

void mach_start_shutdown(void)
{
	force_on_demand = true;
}

void mport_callback(void *obj, struct kevent *kev)
{
	struct kevent newkev;

	launchd_assumes(read(active_ports_fd, &newkev, sizeof(newkev)) != -1);

	newkev.udata = port_to_obj[MACH_PORT_INDEX(newkev.ident)];

	(*((kq_callback *)newkev.udata))(newkev.udata, &newkev);
}

void mach_init_init(void)
{
	pthread_attr_t attr;
	int pipepair[2];

	init_ports();

	launchd_assert(pipe(pipepair) != -1);

	active_ports_fd = pipepair[0];
	port_to_main_thread_fd = pipepair[1];

	launchd_assert(kevent_mod(active_ports_fd, EVFILT_READ, EV_ADD, 0, 0, &kqmport_callback) != -1);

	launchd_assert((root_bootstrap = bootstrap_new(NULL, MACH_PORT_NULL)) != NULL);
	launchd_assert((ws_bootstrap = bootstrap_new(root_bootstrap, MACH_PORT_NULL)) != NULL);
	
	launchd_assumes(launchd_get_bport(&inherited_bootstrap_port) == KERN_SUCCESS);

	if (getpid() != 1)
		launchd_assumes(inherited_bootstrap_port != MACH_PORT_NULL);

	/* We set this explicitly as we start each child */
	launchd_assumes(launchd_set_bport(MACH_PORT_NULL) == KERN_SUCCESS);

	/* register "self" port with anscestor */		
	if (inherited_bootstrap_port != MACH_PORT_NULL) {
		asprintf(&register_name, "com.apple.launchd.%d", getpid());

		launchd_assumes(bootstrap_register(inherited_bootstrap_port, register_name,
					root_bootstrap->bootstrap_port) == KERN_SUCCESS);
	}

	pthread_attr_init(&attr);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);

	launchd_assert(pthread_create(&demand_thread, &attr, demand_loop, NULL) == 0);

	pthread_attr_destroy(&attr);

	/* cut off the Libc cache, we don't want to deadlock against ourself */
	bootstrap_port = MACH_PORT_NULL;
}

void mach_init_reap(void)
{
	void *status;

	launchd_assumes(mach_port_destroy(mach_task_self(), demand_port_set) == KERN_SUCCESS);

	launchd_assumes(pthread_join(demand_thread, &status) == 0);
}

void
init_ports(void)
{
	launchd_assert((errno = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_PORT_SET,
					&demand_port_set)) == KERN_SUCCESS);
	
	launchd_assert(launchd_mport_create_recv(&notify_port, &kqbstrap_callback) == KERN_SUCCESS);

	launchd_assert(launchd_mport_watch(notify_port) == KERN_SUCCESS);
	
	launchd_assert(launchd_mport_create_recv(&backup_port, &kqbstrap_callback) == KERN_SUCCESS);

	launchd_assert(launchd_mport_watch(backup_port) == KERN_SUCCESS);
}

bool
server_useless(struct server *serverp)
{
	bool active_bstrap = (serverp->bootstrap->requestor_port != MACH_PORT_NULL);

	return (!active_bstrap || SLIST_EMPTY(&serverp->services) || !serverp->activity);
}

bool
server_active(struct server *serverp)
{
	return (serverp->port || serverp->pid || serverp->active_services);
}

static void
server_reap(struct server *serverp)
{
	int wstatus;

#ifdef PID1_REAP_ADOPTED_CHILDREN
	if (getpid() == 1)
		wstatus = pid1_child_exit_status;
	else
#endif
	launchd_assumes(waitpid(serverp->pid, &wstatus, 0) != -1);

	if (WIFEXITED(wstatus) && WEXITSTATUS(wstatus)) {
		syslog(LOG_NOTICE, "Server %x in bootstrap %x uid %d: \"%s\"[%d]: exited with status: %d",
				serverp->port, serverp->bootstrap->bootstrap_port,
				serverp->uid, serverp->cmd, serverp->pid, WEXITSTATUS(wstatus));
	} else if (WIFSIGNALED(wstatus)) {
		syslog(LOG_NOTICE, "Server %x in bootstrap %x uid %d: \"%s\"[%d]: exited abnormally: %s",
				serverp->port, serverp->bootstrap->bootstrap_port,
				serverp->uid, serverp->cmd, serverp->pid, strsignal(WTERMSIG(wstatus)));
	}

	serverp->pid = 0;
}

static void
server_demand(struct server *serverp)
{
	struct service *servicep;

	/*
	 * For on-demand servers, make sure that the service ports are
	 * back in on-demand portset.  Active service ports should come
	 * back through a PORT_DESTROYED notification.  We only have to
	 * worry about the inactive ports that may have been previously
	 * pulled from the set but never checked-in by the server.
	 */

	SLIST_FOREACH(servicep, &serverp->services, sle) {
		if (!servicep->isActive)
			launchd_assumes(launchd_mport_watch(servicep->port) == KERN_SUCCESS);
	}
}

void
server_reap_port(struct server *serverp)
{
	launchd_assumes(launchd_mport_close_recv(serverp->port) == KERN_SUCCESS);
	serverp->port = MACH_PORT_NULL;
}

void
server_dispatch(struct server *serverp)
{
	if (!server_active(serverp)) {
		if (server_useless(serverp))
			server_delete(serverp);
		else if (serverp->ondemand || force_on_demand)
			server_demand(serverp);
		else
			server_start(serverp);
	}
}

void
server_callback(void *obj, struct kevent *kev)
{
	current_rpc_server = obj;

	if (kev->filter == EVFILT_MACHPORT) {
		if (current_rpc_server->port == kev->ident) {
			struct kevent newkev = *kev;
			newkev.udata = current_rpc_server->bootstrap;
			bootstrap_callback(current_rpc_server->bootstrap, &newkev);
		} else {
			server_start(current_rpc_server);
		}
	} else if (kev->filter == EVFILT_PROC) {
		server_reap(current_rpc_server);
		server_dispatch(current_rpc_server);
	} else {
		launchd_assumes(false);
	}

	current_rpc_server = NULL;
}

void
server_setup(struct server *serverp)
{
	mach_port_t old_port;
	
	if (!launchd_assumes(launchd_mport_create_recv(&serverp->port, serverp) == KERN_SUCCESS))
		goto out_bad;

	/* Request no-senders notification so we can tell when server dies */
	errno = mach_port_request_notification(mach_task_self(), serverp->port, MACH_NOTIFY_NO_SENDERS,
			1, serverp->port, MACH_MSG_TYPE_MAKE_SEND_ONCE, &old_port);
	if (!launchd_assumes(errno == KERN_SUCCESS))
		goto out_bad2;

	/* Add privileged server port to bootstrap port set */
	launchd_assumes(launchd_mport_watch(serverp->port) == KERN_SUCCESS);

	return;
out_bad2:
	launchd_assumes(launchd_mport_close_recv(serverp->port) == KERN_SUCCESS);
out_bad:
	serverp->port = MACH_PORT_NULL;
}

pid_t launchd_fork(void)
{
	return fork_with_bootstrap_port(root_bootstrap->bootstrap_port, false);
}

pid_t launchd_ws_fork(void)
{
	return fork_with_bootstrap_port(ws_bootstrap->bootstrap_port, false);
}

pid_t
fork_with_bootstrap_port(mach_port_t p, bool dealloc)
{
	pid_t r = -1;

	sigprocmask(SIG_BLOCK, &blocked_signals, NULL);

	launchd_assumes(launchd_set_bport(p) == KERN_SUCCESS);

	if (dealloc)
		launchd_assumes(launchd_mport_deallocate(p) == KERN_SUCCESS);

	r = fork();

	if (r != 0) {
		launchd_assumes(launchd_set_bport(MACH_PORT_NULL) == KERN_SUCCESS);
	} else if (r == 0) {
		size_t i;

		for (i = 0; i <= NSIG; i++) {
			if (sigismember(&blocked_signals, i))
				signal(i, SIG_DFL);
		}
	}

	sigprocmask(SIG_UNBLOCK, &blocked_signals, NULL);
	
	return r;
}

static void
server_start(struct server *serverp)
{
	int pid;

	if (server_active(serverp))
		return;

	if (!serverp->port)
		server_setup(serverp);

	serverp->activity = false;

	if (!launchd_assumes(launchd_mport_make_send(serverp->port) == KERN_SUCCESS))
		return;

	pid = fork_with_bootstrap_port(serverp->port, true);
	if (!launchd_assumes(pid != -1)) {
		return;
	} else if (pid == 0) {
		server_start_child(serverp);
	}

	syslog(LOG_INFO, "Launched server %x in bootstrap %x uid %d: \"%s\": [pid %d]",
			serverp->port, serverp->bootstrap->bootstrap_port, serverp->uid, serverp->cmd, pid);

	serverp->pid = pid;
	if (kevent_mod(pid, EVFILT_PROC, EV_ADD, NOTE_EXIT, 0, &serverp->kqserver_callback) == -1)
		goto out_bad;

	return;
out_bad:
	server_reap(serverp);
	server_dispatch(serverp);
}

void
server_start_child(struct server *serverp)
{
	char **argv;
	sigset_t mask;

	argv = argvize(serverp->cmd);

	if (serverp->uid != getuid()) {
		struct passwd *pwd;
		gid_t g;

	       	launchd_assert((pwd = getpwuid(serverp->uid)) != NULL);

		g = pwd->pw_gid;

		launchd_assert(setgroups(1, &g) != -1);

		launchd_assert(setgid(g) != -1);

		launchd_assert(setuid(serverp->uid) != -1);
	}


	launchd_assumes(setsid() != -1);

	sigemptyset(&mask);
	sigprocmask(SIG_SETMASK, &mask, (sigset_t *)NULL);

	setpriority(PRIO_PROCESS, 0, 0);
	launchd_assumes(execv(argv[0], argv) != -1);
	exit(EXIT_FAILURE);
}	

char **
argvize(const char *string)
{
	static char *argv[100], args[1000];
	const char *cp;
	char *argp, term;
	unsigned int nargs;
	
	/*
	 * Convert a command line into an argv for execv
	 */
	nargs = 0;
	argp = args;
	
	for (cp = string; *cp;) {
		while (isspace(*cp))
			cp++;
		term = (*cp == '"') ? *cp++ : '\0';
		if (nargs < 100)
			argv[nargs++] = argp;
		while (*cp && (term ? *cp != term : !isspace(*cp)) && argp < &args[999]) {
			if (*cp == '\\')
				cp++;
			*argp++ = *cp;
			if (*cp)
				cp++;
		}
		*argp++ = '\0';
	}
	argv[nargs] = NULL;
	return argv;
}

static void *
demand_loop(void *arg __attribute__((unused)))
{
	mach_msg_empty_rcv_t dummy;
	kern_return_t dresult;

	for (;;) {
		mach_port_name_array_t members;
		mach_msg_type_number_t membersCnt;
		mach_port_status_t status;
		mach_msg_type_number_t statusCnt;
		unsigned int i;

		/*
		 * Receive indication of message on demand service ports
		 * without actually receiving the message (we'll let the actual
		 * server do that.
		 */
		dresult = mach_msg(&dummy.header, MACH_RCV_MSG|MACH_RCV_LARGE, 0, 0, demand_port_set, 0, MACH_PORT_NULL);
		if (dresult == MACH_RCV_PORT_CHANGED) {
			break;
		} else if (!launchd_assumes(dresult == MACH_RCV_TOO_LARGE)) {
			continue;
		}
		

		/*
		 * Some port(s) now have messages on them, find out
		 * which ones (there is no indication of which port
		 * triggered in the MACH_RCV_TOO_LARGE indication).
		 */
		if (!launchd_assumes(mach_port_get_set_status(mach_task_self(), demand_port_set, &members, &membersCnt) == KERN_SUCCESS))
			continue;

		for (i = 0; i < membersCnt; i++) {
			statusCnt = MACH_PORT_RECEIVE_STATUS_COUNT;
			if (mach_port_get_attributes(mach_task_self(), members[i], MACH_PORT_RECEIVE_STATUS,
							(mach_port_info_t)&status, &statusCnt) != KERN_SUCCESS)
				continue;

			/*
			 * For each port with messages, take it out of the
			 * demand service portset, and inform the main thread
			 * that it might have to start the server responsible
			 * for it.
			 */
			if (status.mps_msgcount) {
				struct kevent kev;

				EV_SET(&kev, members[i], EVFILT_MACHPORT, 0, 0, 0, NULL);
				launchd_assumes(launchd_mport_ignore(members[i]) == KERN_SUCCESS);
				launchd_assumes(write(port_to_main_thread_fd, &kev, sizeof(kev)) != -1);
			}
		}

		launchd_assumes(vm_deallocate(mach_task_self(), (vm_address_t)members,
					(vm_size_t) membersCnt * sizeof(mach_port_name_t)) == KERN_SUCCESS);
	}
	return NULL;
}
								
boolean_t
server_demux(mach_msg_header_t *Request, mach_msg_header_t *Reply)
{
	return bootstrap_server(Request, Reply) ? true : notify_server(Request, Reply);
}

/*
 * server_loop -- pick requests off our service port and process them
 * Also handles notifications
 */
union bootstrapMaxRequestSize {
	union __RequestUnion__x_bootstrap_subsystem req;
	union __ReplyUnion__x_bootstrap_subsystem rep;
};

bool
canReceive(mach_port_t port)
{
	mach_port_type_t p_type;
	
	if (!launchd_assumes(mach_port_type(mach_task_self(), port, &p_type) == KERN_SUCCESS))
		return false;

	return ((p_type & MACH_PORT_TYPE_RECEIVE) != 0);
}


struct server *
server_new(struct bootstrap *bootstrap, const char *cmd, uid_t uid, bool ond)
{
	struct server *serverp;

	syslog(LOG_DEBUG, "adding new server \"%s\" with uid %d", cmd, uid);	
	serverp = calloc(1, sizeof(struct server) + strlen(cmd) + 1);

	if (NULL == serverp)
		goto out;

	SLIST_INIT(&serverp->services);

	serverp->kqserver_callback = server_callback;

	SLIST_INSERT_HEAD(&bootstrap->servers, serverp, sle);

	serverp->bootstrap = bootstrap;

	serverp->uid = uid;

	serverp->ondemand = ond;
	strcpy(serverp->cmd, cmd);

out:
	return serverp;
}
	
struct service *
service_new(struct bootstrap *bootstrap, const char *name, mach_port_t *serviceport, struct server *serverp)
{
	struct service *servicep;

	if ((servicep = calloc(1, sizeof(struct service) + strlen(name) + 1)) == NULL)
		goto out_bad;

	if (serverp) {
		SLIST_INSERT_HEAD(&serverp->services, servicep, sle);
		if (!launchd_assumes(launchd_mport_create_recv(&servicep->port, serverp) == KERN_SUCCESS))
			goto out_bad;

		if (!launchd_assumes(launchd_mport_make_send(servicep->port) == KERN_SUCCESS))
			goto out_bad;
		servicep->server = serverp;
		*serviceport = servicep->port;
		servicep->isActive = false;
	} else {
		SLIST_INSERT_HEAD(&bootstrap->services, servicep, sle);
		servicep->port = *serviceport;
		servicep->isActive = true;
	}
	
	strcpy(servicep->name, name);
	servicep->bootstrap = bootstrap;

	syslog(LOG_INFO, "Created new service %x in bootstrap %x: %s", servicep->port, bootstrap->bootstrap_port, name);
	return servicep;
out_bad:
	if (servicep) {
		if (servicep->port != MACH_PORT_NULL) {
			launchd_assumes(launchd_mport_deallocate(servicep->port) == KERN_SUCCESS);
			launchd_assumes(launchd_mport_close_recv(servicep->port) == KERN_SUCCESS);
		}
		free(servicep);
	}
	return NULL;
}

void
bootstrap_callback(void *obj, struct kevent *kev)
{
	mach_msg_return_t mresult;
	kern_return_t result;

	current_rpc_bootstrap = obj;

	mresult = mach_msg_server_once(server_demux, sizeof(union bootstrapMaxRequestSize), kev->ident,
			MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER)|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0));
	if (!launchd_assumes(mresult == MACH_MSG_SUCCESS))
		syslog(LOG_ERR, "mach_msg_server_once(): %s", mach_error_string(mresult));

	result = launchd_mport_watch(kev->ident);
	/* sometimes this returns KERN_INVALID_NAME, I don't know why yet, but things seem to work */
	launchd_assumes(result == KERN_SUCCESS || result == KERN_INVALID_NAME);

	current_rpc_bootstrap = NULL;
}

struct bootstrap *
bootstrap_new(struct bootstrap *parent, mach_port_t requestorport)
{
	struct bootstrap *bootstrap;

	if ((bootstrap = calloc(1, sizeof(struct bootstrap))) == NULL)
		goto out_bad;

	bootstrap->kqbstrap_callback = bootstrap_callback;

	SLIST_INIT(&bootstrap->sub_bstraps);
	SLIST_INIT(&bootstrap->servers);
	SLIST_INIT(&bootstrap->services);

	if (!launchd_assumes(launchd_mport_create_recv(&bootstrap->bootstrap_port, bootstrap) == KERN_SUCCESS))
		goto out_bad;

	if (!launchd_assumes(launchd_mport_make_send(bootstrap->bootstrap_port) == KERN_SUCCESS))
		goto out_bad;

	if (!launchd_assumes(launchd_mport_watch(bootstrap->bootstrap_port) == KERN_SUCCESS))
		goto out_bad;

	
	if (requestorport != MACH_PORT_NULL) {
		bootstrap->requestor_port = requestorport;
	} else {
		bootstrap->requestor_port = bootstrap->bootstrap_port;
	}

	if (parent) {
		SLIST_INSERT_HEAD(&parent->sub_bstraps, bootstrap, sle);
		bootstrap->parent = parent;
	}

	return bootstrap;

out_bad:
	if (bootstrap) {
		if (bootstrap->bootstrap_port != MACH_PORT_NULL)
			launchd_assumes(launchd_mport_deallocate(bootstrap->bootstrap_port) == KERN_SUCCESS);
		free(bootstrap);
	}
	return NULL;
}

void
bootstrap_delete_anything_with_port(struct bootstrap *bootstrap, mach_port_t port)
{
	struct bootstrap *sub_bstrap, *next_bstrap;
	struct service *servicep, *next_servicep;
	struct server *serverp, *next_serverp;

	/* Mach ports, unlike Unix descriptors, are reference counted. In other
	 * words, when some program hands us a second or subsequent send right
	 * to a port we already have open, the Mach kernel gives us the same
	 * port number back and increments an reference count associated with
	 * the port. This forces us, when discovering that a receive right at
	 * the other end has been deleted, to wander all of our objects to see
	 * what weird places clients might have handed us the same send right
	 * to use.
	 */

	if (bootstrap->requestor_port == port)
		return bootstrap_delete(bootstrap);

	SLIST_FOREACH_SAFE(sub_bstrap, &bootstrap->sub_bstraps, sle, next_bstrap)
		bootstrap_delete_anything_with_port(sub_bstrap, port);

	/* My naive intuition about Mach port semantics and their implications
	 * on our data structures says that we should never need to walk the
	 * server list in this function. Why? Because if the server dies, we
	 * get the port back in a backup notification. We'd never want to
	 * delete it unless the server consciously unregisters the service.
	 * Oh well, let's use launchd_assumes() to find out if we're wrong.
	 */
	SLIST_FOREACH_SAFE(serverp, &bootstrap->servers, sle, next_serverp) {
		SLIST_FOREACH_SAFE(servicep, &serverp->services, sle, next_servicep) {
			if (!launchd_assumes(servicep->port != port))
				service_delete(servicep);
		}
	}

	SLIST_FOREACH_SAFE(servicep, &bootstrap->services, sle, next_servicep) {
		if (servicep->port == port)
			service_delete(servicep);
	}
}

struct service *
bootstrap_lookup_service(struct bootstrap *bootstrap, const char *name)
{
	struct service *servicep;
	struct server *serverp;

	SLIST_FOREACH(serverp, &bootstrap->servers, sle) {
		SLIST_FOREACH(servicep, &serverp->services, sle) {
			if (strcmp(name, servicep->name) == 0)
				return servicep;
		}
	}

	SLIST_FOREACH(servicep, &bootstrap->services, sle) {
		if (strcmp(name, servicep->name) == 0)
				return servicep;
	}

	if (bootstrap->parent == NULL)
		return NULL;

	return bootstrap_lookup_service(bootstrap->parent, name);
}

void
service_delete(struct service *servicep)
{

	if (servicep->server) {
		SLIST_REMOVE(&servicep->server->services, servicep, service, sle);
		syslog(LOG_INFO, "Declared service %s now unavailable", servicep->name);
		launchd_assumes(launchd_mport_close_recv(servicep->port) == KERN_SUCCESS);
	} else {
		SLIST_REMOVE(&servicep->bootstrap->services, servicep, service, sle);
		syslog(LOG_INFO, "Registered service %s deleted", servicep->name);
	}

	launchd_assumes(launchd_mport_deallocate(servicep->port) == KERN_SUCCESS);

	free(servicep);
}

void
service_watch(struct service *servicep)
{
	mach_port_t previous;

	servicep->isActive = true;

	if (servicep->server) {
		launchd_assumes(mach_port_request_notification(mach_task_self(), servicep->port, MACH_NOTIFY_PORT_DESTROYED,
				0, backup_port, MACH_MSG_TYPE_MAKE_SEND_ONCE, &previous) == KERN_SUCCESS);
		servicep->server->activity = true;
		servicep->server->active_services++;
	} else if (launchd_assumes(mach_port_request_notification(mach_task_self(), servicep->port, MACH_NOTIFY_DEAD_NAME,
					0, notify_port, MACH_MSG_TYPE_MAKE_SEND_ONCE, &previous) == KERN_SUCCESS)) {
		if (!launchd_assumes(previous == MACH_PORT_NULL))
			launchd_assumes(launchd_mport_deallocate(previous) == KERN_SUCCESS);
	}
}

static struct service *
port_to_service(struct bootstrap *bootstrap, mach_port_t port)
{
	struct bootstrap *sub_bstrap;
	struct service *servicep;
	struct server *serverp;
	
	SLIST_FOREACH(serverp, &bootstrap->servers, sle) {
		SLIST_FOREACH(servicep, &serverp->services, sle) {
			if (port == servicep->port)
				return servicep;
		}
	}

	SLIST_FOREACH(servicep, &bootstrap->services, sle) {
	  	if (port == servicep->port)
			return servicep;
	}

	SLIST_FOREACH(sub_bstrap, &bootstrap->sub_bstraps, sle) {
	  	if ((servicep = port_to_service(sub_bstrap, port)))
			return servicep;
	}

	return NULL;
}

static void
server_delete(struct server *serverp)
{
	struct service *servicep;

	syslog(LOG_INFO, "Deleting server %s", serverp->cmd);

	SLIST_REMOVE(&serverp->bootstrap->servers, serverp, server, sle);

	while ((servicep = SLIST_FIRST(&serverp->services)))
		service_delete(servicep);

	if (serverp->port)
		server_reap_port(serverp);

	free(serverp);
}	

void
bootstrap_delete(struct bootstrap *bootstrap)
{
	struct bootstrap *sub_bstrap;
	struct server *serverp;
	struct service *servicep;

	if (!launchd_assumes(bootstrap != root_bootstrap))
		return;
	if (!launchd_assumes(bootstrap != ws_bootstrap))
		return;

	while ((sub_bstrap = SLIST_FIRST(&bootstrap->sub_bstraps)))
		bootstrap_delete(sub_bstrap);

	while ((serverp = SLIST_FIRST(&bootstrap->servers)))
		server_delete(serverp);

	while ((servicep = SLIST_FIRST(&bootstrap->services)))
		service_delete(servicep);

	if (bootstrap->requestor_port != MACH_PORT_NULL && bootstrap->requestor_port != bootstrap->bootstrap_port)
		launchd_assumes(launchd_mport_deallocate(bootstrap->requestor_port) == KERN_SUCCESS);

	launchd_assumes(launchd_mport_close_recv(bootstrap->bootstrap_port) == KERN_SUCCESS);

	if (bootstrap->parent)
		SLIST_REMOVE(&bootstrap->parent->sub_bstraps, bootstrap, bootstrap, sle);

	free(bootstrap);
}

#ifdef PID1_REAP_ADOPTED_CHILDREN

static bool mach_init_check_pid_with_bs(struct bootstrap *bootstrap, pid_t p);
bool mach_init_check_pid_with_bs(struct bootstrap *bootstrap, pid_t p)
{
	struct bootstrap *sub_bstrap;
	struct server *serverp;
	struct kevent kev;

	SLIST_FOREACH(serverp, &bootstrap->servers, sle) {
		if (serverp->pid == p) {
			EV_SET(&kev, p, EVFILT_PROC, 0, 0, 0, serverp);
			serverp->kqserver_callback(serverp, &kev);
			return true;
		}
	}

	SLIST_FOREACH(sub_bstrap, &bootstrap->sub_bstraps, sle) {
		if (mach_init_check_pid_with_bs(sub_bstrap, p))
			return true;
	}

	return false;
}

bool mach_init_check_pid(pid_t p)
{
	return mach_init_check_pid_with_bs(root_bootstrap, p);
}
#endif


kern_return_t
launchd_set_bport(mach_port_t name)
{
	return errno = task_set_bootstrap_port(mach_task_self(), name);
}

kern_return_t
launchd_get_bport(mach_port_t *name)
{
	return errno = task_get_bootstrap_port(mach_task_self(), name);
}

kern_return_t
launchd_mport_watch(mach_port_t name)
{
	return errno = mach_port_move_member(mach_task_self(), name, demand_port_set);
}

kern_return_t
launchd_mport_ignore(mach_port_t name)
{
	return errno = mach_port_move_member(mach_task_self(), name, MACH_PORT_NULL);
}

kern_return_t
launchd_mport_make_send(mach_port_t name)
{
	return errno = mach_port_insert_right(mach_task_self(), name, name, MACH_MSG_TYPE_MAKE_SEND);
}

kern_return_t
launchd_mport_close_recv(mach_port_t name)
{
	if (launchd_assumes(port_to_obj != NULL))
		port_to_obj[MACH_PORT_INDEX(name)] = NULL;

	return errno = mach_port_mod_refs(mach_task_self(), name, MACH_PORT_RIGHT_RECEIVE, -1);
}

kern_return_t
launchd_mport_create_recv(mach_port_t *name, void *obj)
{
	size_t needed_size;
	kern_return_t result;

	result = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, name);

	if (result != KERN_SUCCESS)
		return errno = result;

	needed_size = (MACH_PORT_INDEX(*name) + 1) * sizeof(void *);

	if (needed_size > port_to_obj_size) {
		if (port_to_obj == NULL) {
			launchd_assumes((port_to_obj = calloc(1, needed_size * 2)) != NULL);
		} else {
			launchd_assumes((port_to_obj = reallocf(port_to_obj, needed_size * 2)) != NULL);
			memset((uint8_t *)port_to_obj + port_to_obj_size, 0, needed_size * 2 - port_to_obj_size);
		}
		port_to_obj_size = needed_size * 2;
	}

	launchd_assumes(port_to_obj[MACH_PORT_INDEX(*name)] == NULL);

	port_to_obj[MACH_PORT_INDEX(*name)] = obj;

	return errno = result;
}

kern_return_t
launchd_mport_deallocate(mach_port_t name)
{
	return errno = mach_port_deallocate(mach_task_self(), name);
}


#define bsstatus(servicep) \
	(((servicep)->isActive) ? BOOTSTRAP_STATUS_ACTIVE : \
	 (((servicep)->server && (servicep)->server->ondemand) ? \
		BOOTSTRAP_STATUS_ON_DEMAND : BOOTSTRAP_STATUS_INACTIVE))

/*
 * kern_return_t
 * bootstrap_create_server(mach_port_t bootstrap_port,
 *	 cmd_t server_cmd,
 *	 integer_t server_uid,
 *	 bool on_demand,
 *	 mach_port_t *server_portp)
 *
 * Returns send rights to server_port of service.  At this point, the
 * server appears active, so nothing will try to launch it.  The server_port
 * can be used to delare services associated with this server by calling
 * bootstrap_create_service() and passing server_port as the bootstrap port.
 *
 * Errors:	Returns appropriate kernel errors on rpc failure.
 *		Returns BOOTSTRAP_NOT_PRIVILEGED, if bootstrap port invalid.
 */
__private_extern__ kern_return_t
x_bootstrap_create_server(mach_port_t bootstrapport, cmd_t server_cmd_raw, uid_t server_uid, boolean_t on_demand,
		security_token_t sectoken, mach_port_t *server_portp)
{
	char server_cmd[sizeof(cmd_t) + 1];
	struct bootstrap *bootstrap = current_rpc_bootstrap;
	struct server *serverp;

	/* cmd_t is an array of characters with no promise of being null terminated */
	strlcpy(server_cmd, server_cmd_raw, sizeof(server_cmd));

	uid_t client_euid = sectoken.val[0];

	syslog(LOG_DEBUG, "Server create attempt: \"%s\" bootstrap %x", server_cmd, bootstrapport);

#define LET_MERE_MORTALS_ADD_SERVERS_TO_PID1
	/* XXX - This code should go away once the per session launchd is integrated with the rest of the system */
#ifdef LET_MERE_MORTALS_ADD_SERVERS_TO_PID1
	if (getpid() == 1) {
		if (client_euid != 0 && client_euid != server_uid) {
			syslog(LOG_WARNING, "Server create: \"%s\": Will run as UID %d, not UID %d as they told us to",
					server_cmd, client_euid, server_uid);
			server_uid = client_euid;
		}
		if (client_euid == 0 && strstr(server_cmd, "WindowServer"))
			bootstrap = ws_bootstrap;
	} else
#endif
	if (client_euid != 0 && client_euid != getuid()) {
		syslog(LOG_ALERT, "Security: UID %d somehow acquired the bootstrap port of UID %d and tried to create a server. Denied.",
				client_euid, getuid());
		return BOOTSTRAP_NOT_PRIVILEGED;
	} else if (server_uid != getuid()) {
		syslog(LOG_WARNING, "Server create: \"%s\": As UID %d, we will not be able to switch to UID %d",
				server_cmd, getuid(), server_uid);
		server_uid = getuid();
	}

	serverp = server_new(bootstrap, server_cmd, server_uid, on_demand);
	server_setup(serverp);

	syslog(LOG_INFO, "New server %x in bootstrap %x: \"%s\"", serverp->port, bootstrapport, server_cmd);
	*server_portp = serverp->port;
	return BOOTSTRAP_SUCCESS;
}

/*
 * kern_return_t
 * bootstrap_unprivileged(mach_port_t bootstrapport,
 *			  mach_port_t *unprivportp)
 *
 * Given a bootstrap port, return its unprivileged equivalent.  If
 * the port is already unprivileged, another reference to the same
 * port is returned.
 *
 * This is most often used by servers, which are launched with their
 * bootstrap port set to the privileged port for the server, to get
 * an unprivileged version of the same port for use by its unprivileged
 * children (or any offspring that it does not want to count as part
 * of the "server" for mach_init registration and re-launch purposes).
 */
__private_extern__ kern_return_t
x_bootstrap_unprivileged(mach_port_t bootstrapport, mach_port_t *unprivportp)
{
	struct bootstrap *bootstrap = current_rpc_bootstrap;

	*unprivportp = bootstrap->bootstrap_port;

	syslog(LOG_DEBUG, "Get unpriv bootstrap %x returned for bootstrap %x", bootstrap->bootstrap_port, bootstrapport);
	return BOOTSTRAP_SUCCESS;
}

  
/*
 * kern_return_t
 * bootstrap_check_in(mach_port_t bootstrapport,
 *	 name_t servicename,
 *	 mach_port_t *serviceportp)
 *
 * Returns receive rights to service_port of service named by service_name.
 *
 * Errors:	Returns appropriate kernel errors on rpc failure.
 *		Returns BOOTSTRAP_UNKNOWN_SERVICE, if service does not exist.
 *		Returns BOOTSTRAP_SERVICE_NOT_DECLARED, if service not declared
 *			in /etc/bootstrap.conf.
 *		Returns BOOTSTRAP_SERVICE_ACTIVE, if service has already been
 *			registered or checked-in.
 */
__private_extern__ kern_return_t
x_bootstrap_check_in(mach_port_t bootstrapport, name_t servicename_raw, mach_port_t *serviceportp)
{
	char servicename[sizeof(name_t) + 1];
	struct bootstrap *bootstrap = current_rpc_bootstrap;
	struct server *serverp = current_rpc_server;
	kern_return_t result;
	struct service *servicep;

	/* name_t is an array of characters with no promise of being null terminated */
	strlcpy(servicename, servicename_raw, sizeof(servicename));

	syslog(LOG_DEBUG, "Service checkin attempt for service %s bootstrap %x", servicename, bootstrapport);

	servicep = bootstrap_lookup_service(bootstrap, servicename);
	if (servicep == NULL || servicep->port == MACH_PORT_NULL) {
		syslog(LOG_DEBUG, "bootstrap_check_in service %s unknown%s", servicename, inherited_bootstrap_port != MACH_PORT_NULL ? " forwarding" : "");
		result = BOOTSTRAP_UNKNOWN_SERVICE;
		if (inherited_bootstrap_port != MACH_PORT_NULL)
			result = bootstrap_check_in(inherited_bootstrap_port, servicename, serviceportp);
		return result;
	}
	if (servicep->server != NULL && servicep->server != serverp) {
		syslog(LOG_DEBUG, "bootstrap_check_in service %s not privileged", servicename);
		 return BOOTSTRAP_NOT_PRIVILEGED;
	}
	if (!canReceive(servicep->port)) {
		launchd_assumes(servicep->isActive);
		syslog(LOG_DEBUG, "bootstrap_check_in service %s already active", servicename);
		return BOOTSTRAP_SERVICE_ACTIVE;
	}

	service_watch(servicep);

	syslog(LOG_INFO, "Checkin service %x in bootstrap %x: %s", servicep->port, servicep->bootstrap->bootstrap_port, servicep->name);

	*serviceportp = servicep->port;
	return BOOTSTRAP_SUCCESS;
}

/*
 * kern_return_t
 * bootstrap_register(mach_port_t bootstrapport,
 *	name_t servicename,
 *	mach_port_t serviceport)
 *
 * Registers send rights for the port service_port for the service named by
 * service_name.  Registering a declared service or registering a service for
 * which bootstrap has receive rights via a port backup notification is
 * allowed.
 * The previous service port will be deallocated.  Restarting services wishing
 * to resume service for previous clients must first attempt to checkin to the
 * service.
 *
 * Errors:	Returns appropriate kernel errors on rpc failure.
 *		Returns BOOTSTRAP_NOT_PRIVILEGED, if request directed to
 *			unprivileged bootstrap port.
 *		Returns BOOTSTRAP_SERVICE_ACTIVE, if service has already been
 *			register or checked-in.
 */
__private_extern__ kern_return_t
x_bootstrap_register(mach_port_t bootstrapport, name_t servicename_raw, mach_port_t serviceport)
{
	char servicename[sizeof(name_t) + 1];
	struct bootstrap *bootstrap = current_rpc_bootstrap;
	struct server *serverp = current_rpc_server;
	struct service *servicep;

	/* name_t is an array of characters with no promise of being null terminated */
	strlcpy(servicename, servicename_raw, sizeof(servicename));

	syslog(LOG_DEBUG, "Register attempt for service %s port %x", servicename, serviceport);

	/*
	 * If this bootstrap port is for a server, or it's an unprivileged
	 * bootstrap can't register the port.
	 */
	servicep = bootstrap_lookup_service(bootstrap, servicename);
	if (servicep && servicep->server && servicep->server != serverp)
		return BOOTSTRAP_NOT_PRIVILEGED;

	if (servicep && servicep->bootstrap == bootstrap) {
		if (servicep->isActive) {
			syslog(LOG_DEBUG, "Register: service %s already active, port %x", servicep->name, servicep->port);
			launchd_assumes(!canReceive(servicep->port));
			return BOOTSTRAP_SERVICE_ACTIVE;
		}
		if (servicep->server)
			serverp->activity = true;
		service_delete(servicep);
	}
	servicep = service_new(bootstrap, servicename, &serviceport, NULL);

	service_watch(servicep);

	syslog(LOG_INFO, "Registered service %x bootstrap %x: %s", servicep->port, servicep->bootstrap->bootstrap_port, servicep->name);

	return BOOTSTRAP_SUCCESS;
}

/*
 * kern_return_t
 * bootstrap_look_up(mach_port_t bootstrapport,
 *	name_t servicename,
 *	mach_port_t *serviceportp)
 *
 * Returns send rights for the service port of the service named by
 * service_name in *service_portp.  Service is not guaranteed to be active.
 *
 * Errors:	Returns appropriate kernel errors on rpc failure.
 *		Returns BOOTSTRAP_UNKNOWN_SERVICE, if service does not exist.
 */
__private_extern__ kern_return_t
x_bootstrap_look_up(mach_port_t bootstrapport, name_t servicename_raw, mach_port_t *serviceportp)
{
	char servicename[sizeof(name_t) + 1];
	struct bootstrap *bootstrap = current_rpc_bootstrap;
	struct service *servicep;

	/* name_t is an array of characters with no promise of being null terminated */
	strlcpy(servicename, servicename_raw, sizeof(servicename));

	servicep = bootstrap_lookup_service(bootstrap, servicename);
	if (servicep == NULL || servicep->port == MACH_PORT_NULL) {
		if (inherited_bootstrap_port != MACH_PORT_NULL) {
			syslog(LOG_DEBUG, "bootstrap_look_up service %s forwarding", servicename);
			return bootstrap_look_up(inherited_bootstrap_port, servicename, serviceportp);
		} else {
			syslog(LOG_DEBUG, "bootstrap_look_up service %s unknown", servicename);
			return BOOTSTRAP_UNKNOWN_SERVICE;
		}
	}
	*serviceportp = servicep->port;
	syslog(LOG_DEBUG, "Lookup returns port %x for service %s", servicep->port, servicep->name);
	return BOOTSTRAP_SUCCESS;
}

/*
 * kern_return_t
 * bootstrap_look_up_array(mach_port_t bootstrapport,
 *	name_array_t	servicenames,
 *	int		servicenames_cnt,
 *	mach_port_array_t	*serviceports,
 *	int		*serviceports_cnt,
 *	bool	*allservices_known)
 *
 * Returns port send rights in corresponding entries of the array service_ports
 * for all services named in the array service_names.  Service_ports_cnt is
 * returned and will always equal service_names_cnt (assuming service_names_cnt
 * is greater than or equal to zero).
 *
 * Errors:	Returns appropriate kernel errors on rpc failure.
 *		Returns BOOTSTRAP_NO_MEMORY, if server couldn't obtain memory
 *			for response.
 *		Unknown service names have the corresponding service
 *			port set to MACH_PORT_NULL.
 *		If all services are known, all_services_known is true on
 *			return,
 *		if any service is unknown, it's false.
 */
__private_extern__ kern_return_t
x_bootstrap_look_up_array(mach_port_t bootstrapport, name_array_t servicenames, unsigned int servicenames_cnt,
		mach_port_array_t *serviceportsp, unsigned int *serviceports_cnt, boolean_t *allservices_known)
{
	unsigned int i;
	static mach_port_t service_ports[BOOTSTRAP_MAX_LOOKUP_COUNT];
	
	if (servicenames_cnt > BOOTSTRAP_MAX_LOOKUP_COUNT)
		return BOOTSTRAP_BAD_COUNT;
	*serviceports_cnt = servicenames_cnt;
	*allservices_known = true;
	for (i = 0; i < servicenames_cnt; i++) {
		if (x_bootstrap_look_up(bootstrapport, servicenames[i], &service_ports[i]) != BOOTSTRAP_SUCCESS) {
			*allservices_known = false;
			service_ports[i] = MACH_PORT_NULL;
		}
	}
	syslog(LOG_DEBUG, "bootstrap_look_up_array returns %d ports", servicenames_cnt);
	*serviceportsp = service_ports;
	return BOOTSTRAP_SUCCESS;
}

/*
 * kern_return_t
 * bootstrap_parent(mach_port_t bootstrapport,
 *		    mach_port_t *parentport);
 *
 * Given a bootstrap subset port, return the parent bootstrap port.
 * If the specified bootstrap port is already the root subset, we
 * return the port again. This is a bug. It should return
 * MACH_PORT_NULL, but now we're locked in since apps expect this 
 * behavior. Sigh...
 *
 *
 * Errors:
 *	Returns BOOTSTRAP_NOT_PRIVILEGED if the caller is not running
 *	with an effective user id of root (as determined by the security
 *	token in the message trailer).
 */
__private_extern__ kern_return_t
x_bootstrap_parent(mach_port_t bootstrapport, security_token_t sectoken, mach_port_t *parentport)
{
	struct bootstrap *bootstrap = current_rpc_bootstrap;
	uid_t u = sectoken.val[0];

	syslog(LOG_DEBUG, "Parent attempt for bootstrap %x", bootstrapport);

	if (u) {
		syslog(LOG_NOTICE, "UID %d was denied an answer to bootstrap_parent().", u);
		return BOOTSTRAP_NOT_PRIVILEGED;
	}
	if (bootstrap->parent) {
		*parentport = bootstrap->parent->bootstrap_port;
	} else if (MACH_PORT_NULL != inherited_bootstrap_port) {
		*parentport = inherited_bootstrap_port;
	} else {
		*parentport = bootstrap->bootstrap_port;
	}
	syslog(LOG_DEBUG, "Returning bootstrap parent %x for bootstrap %x", *parentport, bootstrapport);
	return BOOTSTRAP_SUCCESS;
}

/*
 * kern_return_t
 * bootstrap_status(mach_port_t bootstrapport,
 *	name_t servicename,
 *	bootstrap_status_t *serviceactive);
 *
 * Returns: service_active indicates if service is available.
 *			
 * Errors:	Returns appropriate kernel errors on rpc failure.
 *		Returns BOOTSTRAP_UNKNOWN_SERVICE, if service does not exist.
 */
__private_extern__ kern_return_t
x_bootstrap_status(mach_port_t bootstrapport, name_t servicename_raw, bootstrap_status_t *serviceactivep)
{
	char servicename[sizeof(name_t) + 1];
	struct bootstrap *bootstrap = current_rpc_bootstrap;
	struct service *servicep;

	/* name_t is an array of characters with no promise of being null terminated */
	strlcpy(servicename, servicename_raw, sizeof(servicename));

	servicep = bootstrap_lookup_service(bootstrap, servicename);
	if (servicep == NULL) {
		if (inherited_bootstrap_port != MACH_PORT_NULL) {
			syslog(LOG_DEBUG, "bootstrap_status forwarding status, server %s", servicename);
			return bootstrap_status(inherited_bootstrap_port, servicename, serviceactivep);
		} else {
			syslog(LOG_DEBUG, "bootstrap_status service %s unknown", servicename);
			return BOOTSTRAP_UNKNOWN_SERVICE;
		}
	}
	*serviceactivep = bsstatus(servicep);

	syslog(LOG_DEBUG, "bootstrap_status server %s %sactive", servicename, servicep->isActive ? "" : "in");
	return BOOTSTRAP_SUCCESS;
}

/*
 * kern_return_t
 * bootstrap_info(mach_port_t bootstrapport,
 *	name_array_t *servicenamesp,
 *	int *servicenames_cnt,
 *	name_array_t *servernamesp,
 *	int *servernames_cnt,
 *	bootstrap_status_array_t *serviceactivesp,
 *	int *serviceactive_cnt);
 *
 * Returns bootstrap status for all known services.
 *			
 * Errors:	Returns appropriate kernel errors on rpc failure.
 */
__private_extern__ kern_return_t
x_bootstrap_info(mach_port_t bootstrapport, name_array_t *servicenamesp, unsigned int *servicenames_cnt,
		name_array_t *servernamesp, unsigned int *servernames_cnt,
		bootstrap_status_array_t *serviceactivesp, unsigned int *serviceactives_cnt)
{
	struct bootstrap *bootstrap = current_rpc_bootstrap;
	struct server *serverp;
	struct bootstrap *bstrap_iter;
	kern_return_t result;
	unsigned int i = 0, cnt = 0;
	struct service *servicep;
	name_array_t service_names;
	name_array_t server_names;
	bootstrap_status_array_t service_actives;

	for (bstrap_iter = bootstrap; bstrap_iter; bstrap_iter = bstrap_iter->parent) {
		SLIST_FOREACH(serverp, &bstrap_iter->servers, sle) {
			SLIST_FOREACH(servicep, &serverp->services, sle)
				cnt++;
		}
		SLIST_FOREACH(servicep, &bstrap_iter->services, sle)
			cnt++;
	}

	result = vm_allocate(mach_task_self(), (vm_address_t *)&service_names, cnt * sizeof(service_names[0]), true);
	if (result != KERN_SUCCESS)
		return BOOTSTRAP_NO_MEMORY;

	result = vm_allocate(mach_task_self(), (vm_address_t *)&server_names, cnt * sizeof(server_names[0]), true);
	if (result != KERN_SUCCESS) {
		(void)vm_deallocate(mach_task_self(), (vm_address_t)service_names, cnt * sizeof(service_names[0]));
		return BOOTSTRAP_NO_MEMORY;
	}
	result = vm_allocate(mach_task_self(), (vm_address_t *)&service_actives, cnt * sizeof(service_actives[0]), true);
	if (result != KERN_SUCCESS) {
		(void)vm_deallocate(mach_task_self(), (vm_address_t)service_names, cnt * sizeof(service_names[0]));
		(void)vm_deallocate(mach_task_self(), (vm_address_t)server_names, cnt * sizeof(server_names[0]));
		return BOOTSTRAP_NO_MEMORY;
	}

	i = 0;
	for (bstrap_iter = bootstrap; bstrap_iter; bstrap_iter = bstrap_iter->parent) {
		SLIST_FOREACH(serverp, &bstrap_iter->servers, sle) {
			SLIST_FOREACH(servicep, &serverp->services, sle) {
				strlcpy(service_names[i], servicep->name, sizeof(service_names[0]));
		    		strlcpy(server_names[i], serverp->cmd, sizeof(server_names[0]));
	    			service_actives[i] = bsstatus(servicep);
				i++;
			}
		}
		SLIST_FOREACH(servicep, &bstrap_iter->services, sle) {
			strlcpy(service_names[i], servicep->name, sizeof(service_names[0]));
			server_names[i][0] = '\0';
	    		service_actives[i] = bsstatus(servicep);
			i++;
		}
	}

	launchd_assumes(i == cnt);

	*servicenamesp = service_names;
	*servernamesp = server_names;
	*serviceactivesp = service_actives;
	*servicenames_cnt = *servernames_cnt = *serviceactives_cnt = cnt;

	return BOOTSTRAP_SUCCESS;
}

/*
 * kern_return_t
 * bootstrap_subset(mach_port_t bootstrapport,
 *		    mach_port_t requestorport,
 *		    mach_port_t *subsetport);
 *
 * Returns a new port to use as a bootstrap port.  This port behaves
 * exactly like the previous bootstrap_port, except that ports dynamically
 * registered via bootstrap_register() are available only to users of this
 * specific subset_port.  Lookups on the subset_port will return ports
 * registered with this port specifically, and ports registered with
 * ancestors of this subset_port.  Duplications of services already
 * registered with an ancestor port may be registered with the subset port
 * are allowed.  Services already advertised may then be effectively removed
 * by registering MACH_PORT_NULL for the service.
 * When it is detected that the requestor_port is destroyed the subset
 * port and all services advertized by it are destroyed as well.
 *
 * Errors:	Returns appropriate kernel errors on rpc failure.
 */
__private_extern__ kern_return_t
x_bootstrap_subset(mach_port_t bootstrapport, mach_port_t requestorport, mach_port_t *subsetportp)
{
	struct bootstrap *bootstrap = current_rpc_bootstrap;
	kern_return_t result;
	struct bootstrap *subset;
	mach_port_t previous;

	syslog(LOG_DEBUG, "Subset create attempt: bootstrap %x, requestor: %x", bootstrapport, requestorport);

	subset = bootstrap_new(bootstrap, requestorport);

	result = mach_port_request_notification(mach_task_self(), requestorport, MACH_NOTIFY_DEAD_NAME, 0,
			notify_port, MACH_MSG_TYPE_MAKE_SEND_ONCE, &previous); 
	if (result != KERN_SUCCESS) {
		syslog(LOG_ERR, "mach_port_request_notification(): %s", mach_error_string(result));
		bootstrap_delete(subset);
	} else if (previous != MACH_PORT_NULL) {
		syslog(LOG_DEBUG, "deallocating old notification port (%x) for requestor %x", previous, requestorport);
		launchd_assumes(launchd_mport_deallocate(previous) == KERN_SUCCESS);
	}

	*subsetportp = subset->bootstrap_port;
	syslog(LOG_INFO, "Created bootstrap subset %x parent %x requestor %x", *subsetportp, bootstrapport, requestorport);
	return BOOTSTRAP_SUCCESS;
}

/*
 * kern_return_t
 * bootstrap_create_service(mach_port_t bootstrapport,
 *		      name_t servicename,
 *		      mach_port_t *serviceportp)
 *
 * Creates a service named "service_name" and returns send rights to that
 * port in "service_port."  The port may later be checked in as if this
 * port were configured in the bootstrap configuration file.
 *
 * Errors:	Returns appropriate kernel errors on rpc failure.
 *		Returns BOOTSTRAP_NAME_IN_USE, if service already exists.
 */
__private_extern__ kern_return_t
x_bootstrap_create_service(mach_port_t bootstrapport, name_t servicename_raw, mach_port_t *serviceportp)
{
	char servicename[sizeof(name_t) + 1];
	struct bootstrap *bootstrap = current_rpc_bootstrap;
	struct server *serverp = current_rpc_server;
	struct service *servicep;

	/* name_t is an array of characters with no promise of being null terminated */
	strlcpy(servicename, servicename_raw, sizeof(servicename));

	syslog(LOG_DEBUG, "Service creation attempt for service %s bootstrap %x", servicename, bootstrapport); 
	servicep = bootstrap_lookup_service(bootstrap, servicename);
	if (servicep) {
		syslog(LOG_DEBUG, "Service creation attempt for service %s failed, service already exists", servicename);
		return BOOTSTRAP_NAME_IN_USE;
	}

	if (serverp)
		serverp->activity = true;

	servicep = service_new(bootstrap, servicename, serviceportp, serverp);

	if (!launchd_assumes(servicep != NULL))
		goto out_bad;

	return BOOTSTRAP_SUCCESS;

out_bad:
	launchd_assumes(launchd_mport_close_recv(*serviceportp) == KERN_SUCCESS);
	return BOOTSTRAP_NO_MEMORY;
}

kern_return_t
do_mach_notify_port_destroyed(mach_port_t notify, mach_port_t rights)
{
	struct service *servicep;
	struct server *serverp;

	launchd_assumes(notify == backup_port);

	if (!launchd_assumes((serverp = port_to_obj[MACH_PORT_INDEX(rights)]) != NULL))
		return KERN_FAILURE;

	SLIST_FOREACH(servicep, &serverp->services, sle) {
		if (servicep->port == rights)
			break;
	}
	launchd_assumes(servicep != NULL);
	/*
	 * Port sent back to us, server died.
	 */
	syslog(LOG_DEBUG, "Service %x bootstrap %x backed up: %s",
			servicep->port, servicep->bootstrap->bootstrap_port, servicep->name);
	launchd_assumes(canReceive(servicep->port));
	servicep->isActive = false;
	serverp->active_services--;
	server_dispatch(serverp);
	return KERN_SUCCESS;
}

kern_return_t
do_mach_notify_port_deleted(mach_port_t notify, mach_port_name_t name)
{
	syslog(LOG_DEBUG, "Port deleted notification: %d", MACH_PORT_INDEX(name));
	return KERN_SUCCESS;
}

kern_return_t
do_mach_notify_no_senders(mach_port_t notify, mach_port_mscount_t mscount)
{
	struct bootstrap *bootstrap = port_to_obj[MACH_PORT_INDEX(notify)];
	struct server *serverp = port_to_obj[MACH_PORT_INDEX(notify)];
		
	launchd_assumes(serverp || bootstrap);

	if (serverp) {
		syslog(LOG_DEBUG, "server %s dropped server port", serverp->cmd);
		server_reap_port(serverp);
		server_dispatch(serverp);
	} else if (bootstrap) {
		syslog(LOG_DEBUG, "Deallocating bootstrap %d: no more clients", MACH_PORT_INDEX(notify));
		bootstrap_delete(bootstrap);
	}

	return KERN_SUCCESS;
}

kern_return_t
do_mach_notify_send_once(mach_port_t notify)
{
	syslog(LOG_DEBUG, "Send-once right went unused");
	return KERN_SUCCESS;
}

kern_return_t
do_mach_notify_dead_name(mach_port_t notify, mach_port_name_t name)
{
	launchd_assumes(notify == notify_port);

	syslog(LOG_DEBUG, "Dead name notification: %d", MACH_PORT_INDEX(name));

	if (name == inherited_bootstrap_port) {
		launchd_assumes(launchd_mport_deallocate(name) == KERN_SUCCESS);
		inherited_bootstrap_port = MACH_PORT_NULL;
	}
		
	bootstrap_delete_anything_with_port(root_bootstrap, name);

	return KERN_SUCCESS;
}
